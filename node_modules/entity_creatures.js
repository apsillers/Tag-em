module.exports = function(utilities, changeListener, outputListener, entities, activeEntities, entitiesByLocation, mapData, construct) {
    var ROT = require("rot");

    var creatures = {};

    var creatureProto = creatures.creatureProto = Object.create(construct.entityProto);
    creatureProto.setHealth = function(healthDelta) {
        this.health += healthDelta;
        if(this.health <= 0) {
            outputListener.emit("output", { message: "The " + this.name + " is destroyed!", visible:true, point:this });
            this.remove();
            changeListener.emit("change", [this.z], ["pos"]);
        } else {
            if(healthDelta < 0 && this.onDamage) { this.onDamage(); }
        }
    };
    creatureProto.health = 1;
    creatureProto.blocking = true;

    creatures.GridBug = function(options) {
        this.id = options.id;
        this.color = options.color || "#F0F";
        if(options.interval) {
            this.intervalTime = options.interval;
        }
        this.timeToNext = this.intervalTime;
        
        this.onCollide = function(entity, isStepper) {
            if(isStepper && entity instanceof construct.Player) {
                outputListener.emit("output", { message: "The grid bug bites!", targets: [entity.id] });
                entity.setHealth(-1);
            }
        }

        this.health = 4;

        this.act = function() {
            var filteredEntities = utilities.filterEntities(this.id, entities);
            var playersInRange = [];

            // find all players visible to this creature
            for(var i in filteredEntities) {
                if(filteredEntities[i] instanceof construct.Player) {
                    playersInRange.push(filteredEntities[i]);
                }
            }

            // there is a player in sight
            if(playersInRange.length > 0) {
                // sort visible players by health then by distance
                playersInRange.sort(function(a,b) {
                    function distance(foo, bar) { return Math.sqrt((foo.x-bar.x)*(foo.x-bar.x) + (foo.y-bar.y)*(foo.y-bar.y)); }
                    return (a.health - b.health) ||
                           (distance(this,a) - distance(this,b));
                });

                // bug's new target is the player's location
                this.target = { x: playersInRange[0].x, y: playersInRange[0].y };
            }

            // if the bug has a target to get to, process toward it
            if(this.target) {
                // use Dijkstra's alg to find next step direction
                // this might someday be too expensive with more entities?
                var passableCallback = utilities.passableOnLevel(entities, this.z);
                var dijkstra = new ROT.Path.Dijkstra(this.target.x, this.target.y, passableCallback);
                var that = this;
                var found = false;
                dijkstra.compute(this.x, this.y, function(x, y) {
                    // first callback is the creature's location
                    if(that.x == x && that.y == y) { return true; }

                    // the second callback has the first step; use that and then mark it found
                    if(!found) { that.step({ x: x - that.x, y: y - that.y }); found = true; }
                    return false;
                });

                // if no path to target exists, give up
                if(!found) {
                    this.target = undefined;
                }
            }
        };

        this.place(options.z, options.x, options.y, true);
    }
    creatures.GridBug.prototype = Object.create(creatureProto);
    creatures.GridBug.prototype.intervalTime = 800;
    creatures.GridBug.prototype.forgettable = true;
    creatures.GridBug.prototype.symbol = 'x';
    creatures.GridBug.prototype.name = 'grid bug';
    creatures.GridBug.prototype.hasBrain = true;

    creatures.Nymph = function(options) {
        this.id = options.id;
        this.color = options.color || "#00F";
        if(options.interval) {
            this.intervalTime = options.interval;
        }
        this.timeToNext = this.intervalTime;
        
        this.onCollide = function(entity, isStepper) {
            if(this.angry && isStepper && entity instanceof construct.Player) {
                entity.setHealth(-1);
                outputListener.emit("output", { message: "The nymph hits!", targets: [entity.id] });
            }

            // if angry or being collided into
            if((this.angry || !isStepper) && entity.inventory) {
                var inv = entity.inventory.filter(function(e) { return e != undefined });
                if(inv.length != 0) {
                    var item = inv[Math.floor(inv.length * Math.random())];
                    var invIndex = entity.inventory.indexOf(item);
                    outputListener.emit("output", { message: "The nymph steals your " + item.name + "!", targets: [entity.id] });
                    delete entity.inventory[invIndex];
                    changeListener.emit("change", [this.z], ["inventory"], [entity.id], { change: "remove", slot: invIndex });
                    var newLoc = utilities.getValidPosition(this.z);
                    this.setLoc(this.z, newLoc.x, newLoc.y);
                }
            }

        }

        this.health = 5;

        this.angry = false;
        this.onDamage = function() { this.angry = true; }

        this.act = function() {
            if(!this.angry) {
                Math.random()>0.5?this.step({ x: 1 - Math.floor(Math.random()*3), y: 1 - Math.floor(Math.random()*3) }):null;
                return;
            }

            var filteredEntities = utilities.filterEntities(this.id, entities);
            var playersInRange = [];

            // find all players visible to this creature
            for(var i in filteredEntities) {
                if(filteredEntities[i] instanceof construct.Player) {
                    playersInRange.push(filteredEntities[i]);
                }
            }

            // there is a player in sight
            if(playersInRange.length > 0) {
                // sort visible players by health then by distance
                playersInRange.sort(function(a,b) {
                    function distance(foo, bar) { return Math.sqrt((foo.x-bar.x)*(foo.x-bar.x) + (foo.y-bar.y)*(foo.y-bar.y)); }
                    return (a.health - b.health) ||
                           (distance(this,a) - distance(this,b));
                });

                // bug's new target is the player's location
                this.target = { x: playersInRange[0].x, y: playersInRange[0].y };
            }

            // if the bug has a target to get to, process toward it
            if(this.target) {
                // use Dijkstra's alg to find next step direction
                // this might someday be too expensive with more entities?
                var passableCallback = utilities.passableOnLevel(entities, this.z);
                var dijkstra = new ROT.Path.Dijkstra(this.target.x, this.target.y, passableCallback);
                var that = this;
                var found = false;
                dijkstra.compute(this.x, this.y, function(x, y) {
                    // first callback is the creature's location
                    if(that.x == x && that.y == y) { return true; }

                    // the second callback has the first step; use that and then mark it found
                    if(!found) { that.step({ x: x - that.x, y: y - that.y }); found = true; }
                    return false;
                });

                // if no path to target exists, give up
                if(!found) {
                    this.target = undefined;
                }
            }
        };

        this.place(options.z, options.x, options.y, true);
    }
    creatures.Nymph.prototype = Object.create(creatureProto);
    creatures.Nymph.prototype.intervalTime = 700;
    creatures.Nymph.prototype.forgettable = true;
    creatures.Nymph.prototype.symbol = 'n';
    creatures.Nymph.prototype.name = 'nymph';
    creatures.Nymph.prototype.hasBrain = true;




    return creatures;

};
