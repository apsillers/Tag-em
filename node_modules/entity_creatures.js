module.exports = function(utilities, changeListener, entities, activeEntities, entitiesByLocation, mapData, construct) {
    var ROT = require("rot");

    var creatures = {};

    creatures.GridBug = function(options) {
        this.id = options.id;
        this.symbol = 'x';
        this.hasBrain = true;
        this.color = options.color || "#F0F";
        this.blocking = true;
        if(options.interval) {
            this.timeToNext = options.interval;
            this.intervalTime = options.interval;
        }
        this.onCollide = function(entity) {
            if(entity && entity instanceof construct.Player) {
                entity.setHealth(-1);
            }
        }

        this.health = 4;
	    this.setHealth = function(healthDelta) {
            this.health += healthDelta;
            if(this.health <= 0) {
	            this.remove();
	            changeListener.emit("change", [this.z], ["pos"]);
            }
        };

        this.act = function() {
            var filteredEntities = utilities.filterEntities(this.id, entities);
            var playersInRange = [];

            // find all players visible to this creature
            for(var i in filteredEntities) {
                if(filteredEntities[i] instanceof construct.Player) {
                    playersInRange.push(filteredEntities[i]);
                }
            }

            // there is a player in sight
            if(playersInRange.length > 0) {
                // sort visible players by health then by distance
                playersInRange.sort(function(a,b) {
                    function distance(foo, bar) { return Math.sqrt((foo.x-bar.x)*(foo.x-bar.x) + (foo.y-bar.y)*(foo.y-bar.y)); }
                    return (a.health - b.health) ||
                           (distance(this,a) - distance(this,b));
                });

                // use Dijkstra's alg to find next step direction
                // this might someday be too expensive with more entities?
                var passableCallback = utilities.lightPassesOnLevel(entities, this.z);
                var dijkstra = new ROT.Path.Dijkstra(playersInRange[0].x, playersInRange[0].y, passableCallback);
                var that = this;
                var found = false;
                dijkstra.compute(this.x, this.y, function(x, y) {
                    // first callback is the creature's location
                    if(that.x == x && that.y == y) { return true; }

                    // the second callback has the first step; use that and then mark it found
                    if(!found) { that.step({ x: x - that.x, y: y - that.y }); found = true; }
                    return false;
                });

                /*
                // compute simple unit vector toward target players
                var dx = -Math.abs(this.x - playersInRange[0].x) / (this.x - playersInRange[0].x || 1);
                var dy = -Math.abs(this.y - playersInRange[0].y) / (this.y - playersInRange[0].y || 1);
                var vector = {
                    x: dx,
                    y: dy
                }
                var stepResult = this.step(vector);
                */
            }
        };

        this.place(options.z, options.x, options.y, true);
    }
    creatures.GridBug.prototype = Object.create(construct.entityProto);

    return creatures;

};
