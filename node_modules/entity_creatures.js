module.exports = function(utilities, changeListener, outputListener, entities, activeEntities, entitiesByLocation, mapData, construct) {
    var ROT = require("rot");

    var creatures = {};

    creatures.GridBug = function(options) {
        this.id = options.id;
        this.color = options.color || "#F0F";
        this.blocking = true;
        if(options.interval) {
            this.intervalTime = options.interval;
        }
        this.timeToNext = this.intervalTime;
        
        this.onCollide = function(entity, isStepper) {
            if(isStepper && entity instanceof construct.Player) {
                entity.setHealth(-1);
                outputListener.emit("output", { message: "The grid bug bites!", targets: [entity.id] });
            }
        }

        this.health = 4;
	    this.setHealth = function(healthDelta) {
            this.health += healthDelta;
            if(this.health <= 0) {
	            this.remove();
	            changeListener.emit("change", [this.z], ["pos"]);
            }
        };

        this.act = function() {
            var filteredEntities = utilities.filterEntities(this.id, entities);
            var playersInRange = [];

            // find all players visible to this creature
            for(var i in filteredEntities) {
                if(filteredEntities[i] instanceof construct.Player) {
                    playersInRange.push(filteredEntities[i]);
                }
            }

            // there is a player in sight
            if(playersInRange.length > 0) {
                // sort visible players by health then by distance
                playersInRange.sort(function(a,b) {
                    function distance(foo, bar) { return Math.sqrt((foo.x-bar.x)*(foo.x-bar.x) + (foo.y-bar.y)*(foo.y-bar.y)); }
                    return (a.health - b.health) ||
                           (distance(this,a) - distance(this,b));
                });

                // bug's new target is the player's location
                this.target = { x: playersInRange[0].x, y: playersInRange[0].y };
            }

            // if the bug has a target to get to, process toward it
            if(this.target) {
                // use Dijkstra's alg to find next step direction
                // this might someday be too expensive with more entities?
                var passableCallback = utilities.passableOnLevel(entities, this.z);
                var dijkstra = new ROT.Path.Dijkstra(this.target.x, this.target.y, passableCallback);
                var that = this;
                var found = false;
                dijkstra.compute(this.x, this.y, function(x, y) {
                    // first callback is the creature's location
                    if(that.x == x && that.y == y) { return true; }

                    // the second callback has the first step; use that and then mark it found
                    if(!found) { that.step({ x: x - that.x, y: y - that.y }); found = true; }
                    return false;
                });

                // if no path to target exists, give up
                if(!found) {
                    this.target = undefined;
                }
            }
        };

        this.place(options.z, options.x, options.y, true);
    }
    creatures.GridBug.prototype = Object.create(construct.entityProto);
    creatures.GridBug.prototype.intervalTime = 800;
    creatures.GridBug.prototype.forgettable = true;
    creatures.GridBug.prototype.symbol = 'x';
    creatures.GridBug.prototype.name = 'grid bug';
    creatures.GridBug.prototype.hasBrain = true;

    return creatures;

};
