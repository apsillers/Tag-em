module.exports = function(utilities, changeListener, entities, activeEntities, entitiesByLocation, mapData) {

    var entityProto = {
        setLoc: function(z,x,y) {
            // remove entity from entitesByLocation
            var entsAtLoc = entitiesByLocation[this.z][this.x+","+this.y];
            if(typeof entsAtLoc != 'undefined') {
                var index = entsAtLoc.indexOf(this);
                if(index != -1) { entsAtLoc.splice(index, 1); }
            }

            // move the entity
            this.x = x;
            this.y = y;
            this.z = z;

            utilities.ensureLevelExists(z);

            // add the entity to a new position in entitiesByLocation
            if(typeof entitiesByLocation[this.z][this.x+","+this.y] != 'undefined') {
                entitiesByLocation[this.z][this.x+","+this.y].push(this);
            } else {
                entitiesByLocation[this.z][this.x+","+this.y] = [this];
            }
        },
        
        remove: function() {
            delete entities[this.id];
            delete activeEntities[this.id];

            if(typeof entitiesByLocation[this.z] != 'undefined') {
                var entsAtLoc = entitiesByLocation[this.z][this.x+","+this.y];
                if(typeof entsAtLoc != 'undefined') {
                    var index = entsAtLoc.indexOf(this);
                    if(index != -1) {
                        entsAtLoc.splice(index, 1);
                    }
                }
                changeListener.emit("change", [this.z], ["pos"]);
            }
        },

        // data: x/y/z object
        // pushed: wether this object moved because it was pushed (or it moved volunarily)
        // returns true if step succeeds, or returns whatever object blocked the move
        step: function(data, pushed) {
            var stepper = this;

            // can't move when frozen (but can move from a push)
            if(!pushed && this.frozen) { return false; }

            var newPos = {
                           x: stepper.x + data.x,
                           y: stepper.y + data.y,
                           z: stepper.z + (data.z==undefined?0:data.z)
                         };

            // TODO: stairs; move player & create level if does not already exist
            if(data.z == 1 || data.z == -1) {
                return false;
            }
                        
            // if there is a wall
            if(mapData[newPos.z][newPos.x][newPos.y]) {
                // if the moving thing can dig
                if(stepper.canDig) {
                    mapData[newPos.z][newPos.x][newPos.y] = 0;
                    changeListener.emit("change", [newPos.z], ['map']);
                }

                newPos.blocking = true;
                if(stepper.onCollide) { stepper.onCollide(newPos); }

                // we were blocked not by an entity but by terrain;
                // return an object representing the blocking terrain
                return false;
            }
            
            var destEntities = utilities.getEntitiesByLocation(newPos.z, newPos.x, newPos.y, entities);
            var blockingEntities = destEntities.filter(function(e) { return !!e.blocking });    

            // if there's nothing there, move freely
            if(blockingEntities.length == 0) {
                stepper.setLoc(newPos.z, newPos.x, newPos.y);
                changeListener.emit("change", [newPos.z], ['pos', 'map']);

                for(var i=0; i<destEntities.length; ++i) {
                    if(destEntities[i].onCollide) destEntities[i].onCollide(stepper);
                    if(stepper.onCollide) stepper.onCollide(destEntities[i]);
                }

                return true;
            }
            
            var pushableEntities = destEntities.filter(function(e) { return e.pushable || e.frozen; });

            if(stepper.canPush && pushableEntities.length != 0) {
                var stepResult = true;
                for(var i=0; i<pushableEntities.length; ++i) {
                    pushableEntity = pushableEntities[i];

                    // define where the pushable entity would end up
                    var stepResult = pushableEntity.step(data, true) && stepResult;
                }

                if(stepResult) {
                    stepper.setLoc(newPos.z, newPos.x, newPos.y);

                    for(var i=0; i<destEntities.length; ++i) {
                        if(stepper.onCollide) { stepper.onCollide(destEntities[i]); }
                        if(destEntities[i].onCollide) { destEntities[i].onCollide(stepper); }
                    }
                } else {
                    for(var i=0; i<blockingEntities.length; ++i) {
                        if(stepper.onCollide) { stepper.onCollide(blockingEntities[i]); }
                        if(blockingEntities[i].onCollide) { blockingEntities[i].onCollide(stepper); }
                    }
                }

                changeListener.emit("change", [newPos.z], ['pos']);
                return true;
            }

            for(var i=0; i<blockingEntities.length; ++i) {
                if(stepper.onCollide) { stepper.onCollide(blockingEntities[i]); }
                if(blockingEntities[i].onCollide) { blockingEntities[i].onCollide(stepper); }
            }

            return false;
        }
    }

    var objects = {};

    objects.Pit = function(options) {
        this.id = options.id;
        this.x = options.x;
        this.y = options.y;
        this.z = options.z;
        this.symbol = '.';
        this.color = '#FFF';
        this.invisible = true;
        this.onCollide = function(entity) {
            utilities.ensureLevelExists(entity.z + 1);
            var newPos = utilities.getValidPosition(entity.z + 1);
            entity.setLoc(entity.z + 1, newPos.x, newPos.y);
            this.symbol = "^";
            changeListener.emit("change", [entity.z, entity.z-1], ["pos", "map"]);
        };

        entities[this.id] = this;
        this.setLoc(this.z, this.x, this.y);
    }
    objects.Pit.prototype = entityProto;

    objects.Player = function(options) {
        this.id = options.id;
        this.x = options.x;
        this.y = options.y;
        this.z = options.z;
        this.symbol = '@';
        this.color = options.color;
        this.blocking = true;
        this.canPush = true;
        this.canDig = true;
        this.hasBrain = true;
        this.health = options.health;
	    this.setHealth = function(healthDelta) {
            this.health += healthDelta;
            if(this.health <= 0) {
	            var newPlace = utilities.getValidPosition(1);
	            this.x = newPlace.x;
	            this.y = newPlace.y;
	            this.z = 1;
	            this.health = 10;
	            changeListener.emit("change", [this.z], ["pos", "map"]);
            }
        };

        entities[this.id] = this;
        this.setLoc(this.z, this.x, this.y);
    }
    objects.Player.prototype = entityProto;

    objects.Shot = function(options) {
        this.id = options.id;
        this.x = options.x;
        this.y = options.y;
        this.z = options.z;
        this.symbol = '*';
        this.color = options.color || "#FF0";
        this.timeToNext = options.interval;
        this.intervalTime = options.interval;
        this.vector = options.vector;
        this.act = function() {
            this.step(this.vector);
        };
        this.onCollide = function(entity) {
            if(!entity) return;

            if(entity.blocking) {
                var level = this.z;
                this.remove();

                entity.frozen = true;
                setTimeout(function() { entity.frozen = false; }, 2000);
                changeListener.emit("change", [level], ['pos']);
            }
        }

        entities[this.id] = this;        
        activeEntities[this.id] = this;
        this.setLoc(this.z, this.x, this.y);
    }
    objects.Shot.prototype = entityProto;

    objects.Boulder = function(options) {
        this.id = options.id;
        this.x = options.x;
        this.y = options.y;
        this.z = options.z;
        this.symbol = '0';
        this.color = '#FFF';
        this.pushable = true;
        this.blocking = true;

        entities[this.id] = this;
        this.setLoc(this.z, this.x, this.y);
    }
    objects.Boulder.prototype = entityProto;

    objects.Door = function(options) {
        this.id = options.id;
        this.x = options.x;
        this.y = options.y;
        this.z = options.z;
        this.symbol = '+';
        this.otherSymbol = options.otherSymbol;
        this.isOpen = options.isOpen || false;
        this.blocksLight = true;
        this.blocking = true;
        this.color = "#FF0";

        entities[this.id] = this;
        this.setLoc(this.z, this.x, this.y);
    }
    objects.Door.prototype = entityProto;

    objects.Mine = function(options) {
        this.id = options.id;
        this.x = options.x;
        this.y = options.y;
        this.z = options.z;
        this.symbol = '.';
        this.color = "#FFF";
        this.sisterMineIds = options.sisterMineIds;
        this.invisible = true;

        this.onCollide = function(entity) {
	        changeListener.emit("change", [entity.z], ["pos"]);
	        if(typeof entity.health != 'undefined') {
	            entity.setHealth(-10);
	        }
	
	        for(var i = 0; i < 9; i++) {
	            entities[this.sisterMineIds[i]].color = "#F00";
	            entities[this.sisterMineIds[i]].remove();
	        }
        }

        entities[this.id] = this;
        this.setLoc(this.z, this.x, this.y);
    }
    objects.Mine.prototype = entityProto;


    return objects;
}
