module.exports = function(utilities, changeListener, entities, activeEntities, entitiesByLocation, mapData) {

    var objects = {};
    var construct = objects;

    var entityProto = objects.entityProto = {
        setLoc: function(z,x,y) {

            if(this.z != undefined) {
                // remove entity from entitesByLocation
                var entsAtLoc = entitiesByLocation[this.z][this.x+","+this.y];
                if(typeof entsAtLoc != 'undefined') {
                    var index = entsAtLoc.indexOf(this);
                    if(index != -1) { entsAtLoc.splice(index, 1); }
                }
            }

            // move the entity
            this.x = x;
            this.y = y;
            this.z = z;

            utilities.ensureLevelExists(z);

            // add the entity to a new position in entitiesByLocation
            if(typeof entitiesByLocation[this.z][this.x+","+this.y] != 'undefined') {
                entitiesByLocation[this.z][this.x+","+this.y].push(this);
            } else {
                entitiesByLocation[this.z][this.x+","+this.y] = [this];
            }
        },
        
        place: function(z,x,y, active) {
            entities[this.id] = this;
            if(active) { activeEntities[this.id] = this; }
            this.setLoc(z, x, y);
        },

        remove: function() {
            delete entities[this.id];
            delete activeEntities[this.id];

            if(typeof entitiesByLocation[this.z] != 'undefined') {
                var entsAtLoc = entitiesByLocation[this.z][this.x+","+this.y];
                if(typeof entsAtLoc != 'undefined') {
                    var index = entsAtLoc.indexOf(this);
                    if(index != -1) {
                        entsAtLoc.splice(index, 1);
                    }
                }
                changeListener.emit("change", [this.z], ["pos"]);
            }
        },

        // data: x/y/z object
        // pushed: wether this object moved because it was pushed (or it moved volunarily)
        // returns true if step succeeds, or returns whatever object blocked the move
        step: function(data, pushed) {
            var stepper = this;

            // can't move when frozen (but can move from a push)
            if(!pushed && this.frozen) { return false; }

            var newPos = {
                           x: stepper.x + data.x,
                           y: stepper.y + data.y,
                           z: stepper.z + (data.z==undefined?0:data.z)
                         };

            // TODO: stairs; move player & create level if does not already exist
            if(data.z == 1 || data.z == -1) {
                return false;
            }
                        
            // if there is a wall
            if(mapData[newPos.z][newPos.x][newPos.y]) {
                // if the moving thing can dig
                if(stepper.canDig) {
                    mapData[newPos.z][newPos.x][newPos.y] = 0;
                    changeListener.emit("change", [newPos.z], ['map']);
                }

                newPos.blocking = true;
                if(stepper.onCollide) { stepper.onCollide(newPos); }

                // we were blocked not by an entity but by terrain;
                // return an object representing the blocking terrain
                return false;
            }
            
            var destEntities = utilities.getEntitiesByLocation(newPos.z, newPos.x, newPos.y, entities);
            var blockingEntities = destEntities.filter(function(e) { return !!e.blocking });    

            // if there's nothing there, move freely
            if(blockingEntities.length == 0) {
                stepper.setLoc(newPos.z, newPos.x, newPos.y);
                changeListener.emit("change", [newPos.z], ['pos', 'map']);

                for(var i=0; i<destEntities.length; ++i) {
                    if(destEntities[i].onCollide) destEntities[i].onCollide(stepper);
                    if(stepper.onCollide) stepper.onCollide(destEntities[i]);
                }

                return true;
            }
            
            var pushableEntities = destEntities.filter(function(e) { return e.pushable || e.frozen; });

            if(stepper.canPush && pushableEntities.length != 0) {
                var stepResult = true;
                for(var i=0; i<pushableEntities.length; ++i) {
                    pushableEntity = pushableEntities[i];

                    // define where the pushable entity would end up
                    var stepResult = pushableEntity.step(data, true) && stepResult;
                }

                if(stepResult) {
                    stepper.setLoc(newPos.z, newPos.x, newPos.y);

                    for(var i=0; i<destEntities.length; ++i) {
                        if(stepper.onCollide) { stepper.onCollide(destEntities[i]); }
                        if(destEntities[i].onCollide) { destEntities[i].onCollide(stepper); }
                    }
                } else {
                    for(var i=0; i<blockingEntities.length; ++i) {
                        if(stepper.onCollide) { stepper.onCollide(blockingEntities[i]); }
                        if(blockingEntities[i].onCollide) { blockingEntities[i].onCollide(stepper); }
                    }
                }

                changeListener.emit("change", [newPos.z], ['pos']);
                return true;
            }

            for(var i=0; i<blockingEntities.length; ++i) {
                if(stepper.onCollide) { stepper.onCollide(blockingEntities[i]); }
                if(blockingEntities[i].onCollide) { blockingEntities[i].onCollide(stepper); }
            }

            return false;
        }
    }

    objects.Pit = function(options) {
        this.id = options.id;
        this.symbol = '^';
        this.color = '#FFF';
        this.hidden = true;
        this.knownTo = options.knownTo;

        this.place(options.z, options.x, options.y);
    }
    objects.Pit.prototype = Object.create(entityProto);
    objects.Pit.prototype.onCollide = function(entity) {
        // known to player who just fell
        if(this.knownTo.indexOf(entity.id) == -1) { this.knownTo.push(entity.id); }

        // known to all player that saw it
        // TODO: this actually tests if the trapdoor can see the player, so it does not account for reduced player visibility
        var nearbyEntities = utilities.filterEntities(this.id, entities);
        for(var i in nearbyEntities) {
            if(this.knownTo.indexOf(nearbyEntities[i].id) == -1) { this.knownTo.push(nearbyEntities[i].id); }
        }
        
        // drop the player down a level
        utilities.ensureLevelExists(entity.z + 1);
        var newPos = utilities.getValidPosition(entity.z + 1);
        entity.setLoc(entity.z + 1, newPos.x, newPos.y);
        changeListener.emit("change", [entity.z, entity.z-1], ["pos", "map"]);
    };

    objects.Player = function(options) {
        this.id = options.id;
        this.symbol = '@';
        this.color = options.color;
        this.blocking = true;
        this.canPush = true;
        this.canDig = true;
        this.hasBrain = true;
        this.health = options.health;
	    this.setHealth = function(healthDelta) {
            this.health += healthDelta;
            if(this.health <= 0) {
	            var newPlace = utilities.getValidPosition(1);
                this.place(1, newPlace.x, newPlace.y);
	            this.health = 10;
	            changeListener.emit("change", [this.z], ["pos", "map"]);
            }
            changeListener.emit("change", [this.z], ["health"]);
        };

        this.place(options.z, options.x, options.y);
    }
    objects.Player.prototype = Object.create(entityProto);

    var shotProto = objects.shotProto = Object.create(entityProto);
    shotProto.act = function() {
        this.step(this.vector);
    };
    shotProto.timeToNext = 100;
    shotProto.intervalTime = 100;
    
    objects.FreezeShot = function(options) {
        this.id = options.id;
        this.symbol = '*';
        this.color = options.color || "#0FF";
        if(options.interval) {
            this.timeToNext = options.interval;
            this.intervalTime = options.interval;
        }
        this.vector = options.vector;

        this.place(options.z, options.x, options.y, true);
    }
    objects.FreezeShot.prototype = Object.create(shotProto);
    objects.FreezeShot.prototype.onCollide = function(entity) {
        if(!entity) return;

        if(entity.blocking) {
            var level = this.z;
            this.remove();

            entity.frozen = true;
            setTimeout(function() { entity.frozen = false; }, 2000);
            changeListener.emit("change", [level], ['pos']);
        }
    }


    objects.FireballShot = function(options) {
        this.id = options.id;
        this.symbol = '*';
        this.color = options.color || "#F00";
        this.timeToNext = options.interval;
        this.intervalTime = options.interval;
        this.vector = options.vector;

        this.place(options.z, options.x, options.y, true);
    }
    objects.FireballShot.prototype = Object.create(shotProto);
    objects.FireballShot.prototype.onCollide = function(entity) {
        if(!entity) return;

        if(entity.blocking) {
            var level = this.z;
            this.remove();

            if(entity.health) { entity.setHealth(-2); }
            changeListener.emit("change", [level], ['pos']);
        }
    }

    objects.Boulder = function(options) {
        this.id = options.id;
        this.symbol = '0';
        this.color = '#FFF';
        this.pushable = true;
        this.blocking = true;

        this.place(options.z, options.x, options.y);
    }
    objects.Boulder.prototype = Object.create(entityProto);

    objects.Door = function(options) {
        this.id = options.id;
        this.symbol = '+';
        this.otherSymbol = options.otherSymbol;
        this.isOpen = options.isOpen || false;
        this.blocksLight = true;
        this.blocking = true;
        this.color = "#FF0";

        this.place(options.z, options.x, options.y);
    }
    objects.Door.prototype = Object.create(entityProto);

    objects.Mine = function(options) {
        this.id = options.id;
        this.symbol = '.';
        this.color = "#FFF";
        this.sisterMineIds = options.sisterMineIds;
        this.invisible = true;

        this.onCollide = function(entity) {
	        changeListener.emit("change", [entity.z], ["pos"]);
	        if(typeof entity.health != 'undefined') {
	            entity.setHealth(-10);
	        }
	
	        for(var i = 0; i < 9; i++) {
	            entities[this.sisterMineIds[i]].color = "#F00";
	            entities[this.sisterMineIds[i]].remove();
	        }
        }

        this.place(options.z, options.x, options.y);
    }
    objects.Mine.prototype = Object.create(entityProto);


    objects.FreezeWand = function(options) {
        this.id = options.id;
        this.name = "wand of freezing";
        this.symbol = '/';
        this.color = "#0FF";
        this.collectable = true;
        this.shootable = true;

        this.place(options.z, options.x, options.y);
    }
    objects.FreezeWand.prototype = Object.create(entityProto);
    objects.FreezeWand.prototype.onFire = function(id, data) {
        var shotId = utilities.genId();
        new construct.FreezeShot({
            id: shotId,
            color: "#0FF",
            x: entities[id].x,
            y: entities[id].y,
            z: entities[id].z,
            interval: 100,
            vector: data
        });

        changeListener.emit("change", [entities[id].z], ["pos"]);
    }

    objects.FireballWand = function(options) {
        this.id = options.id;
        this.collectable = true;
        this.shootable = true;

        this.place(options.z, options.x, options.y);
    }
    objects.FireballWand.prototype = Object.create(entityProto);
    objects.FireballWand.prototype.name = "wand of fireball";
    objects.FireballWand.prototype.symbol = "/";
    objects.FireballWand.prototype.color = "#F00";
    objects.FireballWand.prototype.onFire = function(id, data) {
        var shotId = utilities.genId();
        new construct.FireballShot({
            id: shotId,
            color: "#F00",
            x: entities[id].x,
            y: entities[id].y,
            z: entities[id].z,
            interval: 100,
            vector: data
        });

        changeListener.emit("change", [entities[id].z], ["pos"]);
    }

    return objects;
}
