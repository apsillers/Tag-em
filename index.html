<script src="rot.min.js"></script>
<script src="/socket.io/socket.io.js"></script>
<script>

ROT.RNG.setSeed(12345);
ROT.DEFAULT_WIDTH = 80;
ROT.DEFAULT_HEIGHT = 32;

var id, level = 1;
var mapData = [];

var display = new ROT.Display({fontSize:12});
document.documentElement.appendChild(display.getContainer());

var socket = io.connect('http://' + location.host);
socket.on("map+pos", function(updates) { redraw(updates.map, updates.pos); });
socket.on("map", function(mapUpdates) { redraw(mapUpdates, positions); });
socket.on("pos", function(pos) { redraw({}, pos); });
socket.on("id", function(myid) {
    id = myid;

    display.clear();
    
    // init empty map
    initMapLevel(1);
});

function initMapLevel(level) {
    mapData[level] = [];
    for(var i=0; i < ROT.DEFAULT_WIDTH; ++i) {
        for(var j=0; j < ROT.DEFAULT_HEIGHT; ++j) {
            if(mapData[level][i] == null) { mapData[level][i] = []; }
            mapData[level][i][j] = -1;
        }
    }
}

var shotMode = false;
var zapMode = false;
var openMode = false;
var closeMode = false;

// do we expect an item identifier
var expectingItem = false;
var itemNum = null;

window.addEventListener("keydown", function(e) {
    var code = e.keyCode;

    var action = "move";
    var mine = "mine";

    if(shotMode) { action = "shoot"; }
    if(zapMode) { action = "zap"; }
    if(openMode) { action = "open"; }
    if(closeMode) { action = "close"; }

    if(expectingItem) {
        itemNum = code - 48;
        expectingItem = false;
    } else {
        if (ROT.VK_H == code) { socket.emit(action, { x:-1, y:0, itemNum: itemNum }); }
        if (ROT.VK_L == code) { socket.emit(action, { x:1, y:0, itemNum: itemNum }); }
        if (ROT.VK_K == code) { socket.emit(action, { x:0, y:-1, itemNum: itemNum }); }
        if (ROT.VK_J == code) { socket.emit(action, { x:0, y:1, itemNum: itemNum }); }
        
        if (ROT.VK_Y == code) { socket.emit(action, { x:-1, y:-1, itemNum: itemNum }); }
        if (ROT.VK_U == code) { socket.emit(action, { x:1, y:-1, itemNum: itemNum }); }
        if (ROT.VK_B == code) { socket.emit(action, { x:-1, y:1, itemNum: itemNum }); }
        if (ROT.VK_N == code) { socket.emit(action, { x:1, y:1, itemNum: itemNum }); }

        shotMode = false;
        zapMode = false;
        openMode = false;
        closeMode = false;
    }

    
    if (ROT.VK_A == code) { 
	action = "mine";
	socket.emit(action);
	}
    if (ROT.VK_Z == code) { zapMode = true; }
    if (ROT.VK_S == code) { shotMode = true; expectingItem = true; console.log("shot mode"); }
    if (ROT.VK_O == code) { openMode = true; }
    if (ROT.VK_C == code) { closeMode = true; }
    

    if (ROT.VK_PERIOD == code && e.shiftKey) { socket.emit("move", { x:0, y:0, z:1 }); }
    if (ROT.VK_COMMA == code) { socket.emit("pickup"); }
});
    
var positions = {};
function drawMap(mapUpdates) {

    if(typeof mapData[level] == 'undefined') { initMapLevel(level); }

    // update map state with new data
    for(i in mapUpdates) {
        var coords = i.split(',');
        mapData[level][coords[0]][coords[1]] = mapUpdates[i];
    }

    // redraw map
    for(i=0; i < ROT.DEFAULT_WIDTH; ++i) {
        for(j=0; j < ROT.DEFAULT_HEIGHT; ++j) {
            drawMapChar(i, j, mapData[level][i][j]==0?".":" ", "#fff", ["#000", "#777"][mapData[level][i][j]]);
        }
    }
}

function drawEntities(posData) {
    for(var i in posData) {
        var pos = posData[i];

        // if entity is a blocking entity (player, boulder), draw it
        if(pos.blocking) { drawMapChar(pos.x, pos.y, pos.symbol, pos.color); }
        else {
            // if entity is non-blocking, defer to any blocking entities on the space
            var hasBlocking = false;
            for(var j in posData) {
                if(posData[j].blocking && posData[j].x == pos.x && posData[j].y == pos.y) {
                    hasBlocking = true;
                    break;
                }
            }
            if(!hasBlocking) { drawMapChar(pos.x, pos.y, pos.symbol, pos.color); }
        }
    }
}

function redraw(map, posData) {
    positions = posData;

    if(positions[id] != undefined) {
        level = positions[id].z;
    }

    drawMap(map);
    drawEntities(posData);
}

function drawMapChar(x,y,ch,fg,bg) {
    display.draw(x, y+2, ch, fg, bg);
}
</script>
